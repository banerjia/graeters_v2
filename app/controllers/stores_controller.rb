class StoresController < ApplicationController
    before_action :set_retailer, :set_state_code
    before_action :set_store, only: [:show]

    @@PAGE_SIZE = 15

    def index

        # Page calculations for basic store search
        page = (params[:page] || 1).to_i
        record_offset = (page - 1) * @@PAGE_SIZE

        # Join vs Include - an INCLUDE will produce two queries while a JOIN will 
        # produce one INNER JOIN query that is much more efficient than two 
        # queries. This will eventually be replaced by an Elastic Search query
        # Alternatively, pagination may be an equally good option. 

        <<-NonESSearch
        @stores = Store \
                    .left_outer_joins(:other_attribute)
                    .joins(:state) \
                    .where({retailer_id: @retailer.id}) \
                    .offset( record_offset )
                    .limit( @@PAGE_SIZE )
                    .select('stores.name, stores.addr_ln_1, stores.addr_ln_2, stores.city, states.code, stores.zip_code, other_attributes.data')
        NonESSearch

        # Determining the starting bound for the search results
        from = ((params[:page] || 1).to_i - 1) * @@PAGE_SIZE

        # Providing the filter for the dataset based on retailer
        es_query_bool_filter = [{ term: {"retailer.id": @retailer.id}}]

        # If a state is specified in the URL add this criteria to 
        # the post_filter so that aggregations are not affected by the state filter
        if !@state.nil?
            es_query_post_filter = {term: {"state.code": @state.code}} unless @state.nil?
        else
            es_query_post_filter = {match_all:{}}
        end

        # Preforming the ES search
        es_search_results = Store.search({
            from: from,
            size: @@PAGE_SIZE,
            query:{
                bool:{
                    must: [],
                    must_not: [],
                    should: [],
                    filter: es_query_bool_filter
                }
            },
            aggs:{
                states:{
                    terms:{
                        field: "state.agg_key",
                        size: 50,
                        order:{
                            "_key":"asc"
                        }
                    }
                },
                regions:{
                    terms:{
                        field: "region.raw",
                        size: 10
                    }
                }
            },
            post_filter: es_query_post_filter
        })

        # Prepare the data to be sent to the view

        # Store results
        @stores = es_search_results.results

        # Aggregations based on the "query" conditions,
        # post_filter does not affect the aggregations
        @aggregations = es_search_results.aggregations

        # Total number of results
        # Maybe provided on the view 
        # Also used to calculate the total number of pages
        @results_found = es_search_results.results.total

        # Calculate total number of pages generated by the query
        @pages = (@results_found/@@PAGE_SIZE)
        @pages += 1 if (@results_found % @@PAGE_SIZE) > 0

        # Pass the params received by the controller,
        # so that links for search pagination are
        # provided with all the 
        @params = params
        @current_page = page

    end

    def show
    end

    private
    def set_retailer
        @retailer = Retailer.where({url: params[:retailer]}).select([:id, :name]).first()
    end

    def set_state_code
        @state = State.find_by_code(params[:state_code]) unless params[:state_code].nil?
    end

    def set_store
        @store = Store.find(params[:id])
    end
end
